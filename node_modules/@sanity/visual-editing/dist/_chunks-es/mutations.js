import{getDraftId as t,getPublishedId as n}from"@sanity/client/csm";import{createIfNotExists as e,patch as r,at as o,insert as s,truncate as i}from"@sanity/mutate";import{isMaybePreviewIframe as u,isMaybePreviewWindow as f}from"@sanity/presentation-comlink";import{useCallback as a,useSyncExternalStore as c,useMemo as p}from"react";import{listeners as d,actor as y,emptyActor as h,isEmptyActor as m}from"../optimistic/index.js";import l from"get-random-values-esm";const g=/_key\s*==\s*['"](.*)['"]/,b=/^\d*:\d*$/;function w(t){return"number"==typeof t||"string"==typeof t&&/^\[\d+\]$/.test(t)}function k(t){return"string"==typeof t?g.test(t.trim()):"object"==typeof t&&"_key"in t}const x=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,_=/_key\s*==\s*['"](.*)['"]/;function I(t,n,e){const r="string"==typeof n?function(t){if("string"!=typeof t)throw new Error("Path is not a string");const n=t.match(x);if(!n)throw new Error("Invalid path string");return n.map(S)}(n):n;if(!Array.isArray(r))throw new Error("Path must be an array or a string");let o=t;for(let t=0;t<r.length;t++){const n=r[t];if(w(n)){if(!Array.isArray(o))return e;o=o[n]}if(k(n)){if(!Array.isArray(o))return e;o=o.find((t=>t._key===n._key))}if("string"==typeof n&&(o="object"==typeof o&&null!==o?o[n]:void 0),typeof o>"u")return e}return o}function S(t){return w(t)?function(t){return Number(t.replace(/[^\d]/g,""))}(t):k(t)?function(t){return{_key:t.match(_)[1]}}(t):function(t){if("string"==typeof t&&b.test(t))return!0;if(!Array.isArray(t)||2!==t.length)return!1;const[n,e]=t;return!("number"!=typeof n&&""!==n||"number"!=typeof e&&""!==e)}(t)?function(t){const[n,e]=t.split(":").map((t=>""===t?t:Number(t)));return[n,e]}(t):t}function E(){const t=a((t=>(d.add(t),()=>d.delete(t))),[]);return c(t,(()=>y),(()=>h))}function A(){const t=E();return p((()=>!m(t)),[t])}function D(t,n){let e;return(...r)=>{clearTimeout(e),e=setTimeout((()=>{t.apply(t,r)}),n)}}function O(e,r){const o=u(),s=f();if(m(r)||!o&&!s)throw new Error("The `useDocuments` hook cannot be used in this context");const i=t(e),a=n(e),c=r.getSnapshot().context?.documents,p=c?.[i],d=c?.[a],y=p||d;if(!y)throw new Error(`Document "${e}" not found`);const h=p.getSnapshot().context?.local||d.getSnapshot().context?.local,l=new Promise((t=>{if(h)t(h);else{const n=y.on("ready",(e=>{const{snapshot:r}=e;t(r||null),n.unsubscribe()}))}}));return{draftDoc:p,draftId:i,getSnapshot:()=>l,publishedDoc:d,publishedId:a,get snapshot(){if(!h)throw new Error(`Snapshot for document "${e}" not found`);return h}}}function v(t,n){return()=>{const{draftDoc:e}=O(t,n);e.send({type:"submit"})}}function $(t,n){return e=>{const{snapshot:r}=O(t,n);return e?I(r,e):r}}function j(t,n){const{getSnapshot:e}=O(t,n);return e}function N(t,n){return async(o,s)=>{const i=O(t,n),{draftDoc:u,draftId:f,getSnapshot:a,publishedId:c}=i,{commit:p=!0}=s||{},d=await("function"==typeof o?o({draftId:f,publishedId:c,get snapshot(){return i.snapshot},getSnapshot:a}):o),y=await a();if(!y)throw new Error(`Snapshot for document "${t}" not found`);u.send({type:"mutate",mutations:[e({...y,_id:f}),r(f,d)]}),p&&("object"==typeof p&&"debounce"in p?D((()=>u.send({type:"submit"})),p.debounce)():u.send({type:"submit"}))}}function P(){const t=E();return{getDocument:a((n=>({id:n,commit:v(n,t),get:$(n,t),getSnapshot:j(n,t),patch:N(n,t)})),[t]),mutateDocument:a(((n,e,r)=>{const{draftDoc:o}=O(n,t),{commit:s=!0}=r||{};o.send({type:"mutate",mutations:e}),s&&("object"==typeof s&&"debounce"in s?D((()=>o.send({type:"submit"})),s.debounce)():o.send({type:"submit"}))}),[t])}}const T=/* @__PURE__ */(()=>{let t;return()=>{if(t)return t;t=[];for(let n=0;n<256;++n)t[n]=(n+256).toString(16).slice(1);return t}})();function K(t){const n=T();return function(t=16){const n=new Uint8Array(t);return l(n),n}(t).reduce(((t,e)=>t+n[e]),"").slice(0,t)}function U(t){const n="string"==typeof t?t:t.path,e=n.lastIndexOf("."),r=n.substring(e+1,n.length);if(!r.indexOf("["))throw new Error("Invalid path: not an array");const o=n.lastIndexOf("["),s=n.substring(0,o);let i,u;if(r.includes("_key")){const t=r.indexOf('"')+1,n=r.indexOf('"',t);i=r.substring(t,n),u=!0}else{const t=r.indexOf("[")+1,n=r.indexOf("]",t);i=r.substring(t,n),u=!1}if(!s||!i)throw new Error("Invalid path");return{path:s,key:i,hasExplicitKey:u}}function q(t,n,e="after"){const{path:r,key:i}=U(t),u={...I(n,t.path),_key:K()};return[o(r,s(u,e,{_key:i}))]}function z(t,n){const{path:e,key:r}=U(t),s=I(n,e).findIndex((t=>t._key===r));return[o(e,i(s,s+1))]}function B(t,n,e){const{path:r,key:i}=U(t),u=K();return[o(r,s([{_type:n,_key:u}],e,{_key:i}))]}async function C(t,n,e){if(!t.type)throw new Error("Node type is missing");const{path:r,key:u}=U(t),f=await n.getSnapshot(),a=I(f,r),c=I(f,t.path),p=a.findIndex((t=>t._key===u));let d=-1,y="before";if("first"===e){if(0===p)return[];d=0,y="before"}else if("last"===e){if(p===a.length-1)return[];d=-1,y="after"}else if("next"===e){if(p===a.length-1)return[];d=p,y="after"}else if("previous"===e){if(0===p)return[];d=p-1,y="before"}return[o(r,i(p,p+1)),o(r,s(c,y,d))]}export{B as a,E as b,I as c,C as d,z as e,q as f,U as g,A as h,P as u};//# sourceMappingURL=mutations.js.map

{"version":3,"file":"mutations.js","sources":["../../../../node_modules/.pnpm/@sanity+types@3.74.0_@types+react@19.0.8_debug@4.4.0/node_modules/@sanity/types/lib/index.mjs","../../../../node_modules/.pnpm/@sanity+util@3.74.0_@types+react@19.0.8_debug@4.4.0/node_modules/@sanity/util/lib/paths.mjs","../../src/react/useOptimisticActor.ts","../../src/react/useDocuments.ts","../../src/util/randomKey.ts","../../src/util/mutations.ts"],"sourcesContent":["function isObject(obj) {\n  return typeof obj == \"object\" && obj !== null && !Array.isArray(obj);\n}\nfunction isReference(reference) {\n  return isObject(reference) && typeof reference._ref == \"string\";\n}\nfunction isImage(value) {\n  return isObject(value) && isReference(value.asset) && value.asset._ref.startsWith(\"image-\");\n}\nfunction isCrossDatasetReference(reference) {\n  return isObject(reference) && typeof reference._ref == \"string\" && typeof reference._dataset == \"string\" && typeof reference._projectId == \"string\";\n}\nfunction isSanityDocument(document) {\n  return isObject(document) && typeof document._id == \"string\" && typeof document._type == \"string\";\n}\nfunction isTypedObject(obj) {\n  return isObject(obj) && typeof obj._type == \"string\";\n}\nfunction isKeyedObject(obj) {\n  return isObject(obj) && typeof obj._key == \"string\";\n}\nfunction isValidationErrorMarker(marker) {\n  return marker.level === \"error\";\n}\nfunction isValidationWarningMarker(marker) {\n  return marker.level === \"warning\";\n}\nfunction isValidationInfoMarker(marker) {\n  return marker.level === \"info\";\n}\nfunction isCreateMutation(mutation) {\n  return \"create\" in mutation;\n}\nfunction isCreateIfNotExistsMutation(mutation) {\n  return \"createIfNotExists\" in mutation;\n}\nfunction isCreateOrReplaceMutation(mutation) {\n  return \"createOrReplace\" in mutation;\n}\nfunction isDeleteMutation(mutation) {\n  return \"delete\" in mutation;\n}\nfunction isPatchMutation(mutation) {\n  return \"patch\" in mutation;\n}\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/, reIndexTuple = /^\\d*:\\d*$/;\nfunction isIndexSegment(segment) {\n  return typeof segment == \"number\" || typeof segment == \"string\" && /^\\[\\d+\\]$/.test(segment);\n}\nfunction isKeySegment(segment) {\n  return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction isIndexTuple(segment) {\n  if (typeof segment == \"string\" && reIndexTuple.test(segment))\n    return !0;\n  if (!Array.isArray(segment) || segment.length !== 2)\n    return !1;\n  const [from, to] = segment;\n  return (typeof from == \"number\" || from === \"\") && (typeof to == \"number\" || to === \"\");\n}\nfunction isRecord$1(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction isPortableTextTextBlock(value) {\n  return isRecord$1(value) && typeof value._type == \"string\" && // block types can be named, so expect anything here.\n  Array.isArray(value.children) && value.children.every((child) => isRecord$1(child)) && (\"markDefs\" in value ? Array.isArray(value.markDefs) && value.markDefs.every((def) => isRecord$1(def)) : !0) && (\"style\" in value ? typeof value.style == \"string\" : !0);\n}\nfunction isPortableTextSpan(value) {\n  return isRecord$1(value) && value._type === \"span\" && typeof value.text == \"string\" && (\"marks\" in value ? Array.isArray(value.marks) && value.marks.every((mark) => typeof mark == \"string\") : !0);\n}\nfunction isPortableTextListBlock(value) {\n  return isPortableTextTextBlock(value) && \"listItem\" in value && typeof value.listItem == \"string\" && \"level\" in value && Number.isInteger(value.level);\n}\nfunction isRecord(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction isDocumentSchemaType(type) {\n  if (!isObjectSchemaType(type))\n    return !1;\n  let current = type;\n  for (; current; ) {\n    if (current.name === \"document\")\n      return !0;\n    current = current.type;\n  }\n  return !1;\n}\nfunction isObjectSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"object\" : !1;\n}\nfunction isArraySchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"array\" : !1;\n}\nfunction isArrayOfBlocksSchemaType(type) {\n  return isArraySchemaType(type) && type.of.some((memberType) => isBlockSchemaType(memberType));\n}\nfunction isArrayOfObjectsSchemaType(type) {\n  return isArraySchemaType(type) && type.of.every((memberType) => isObjectSchemaType(memberType));\n}\nfunction isArrayOfPrimitivesSchemaType(type) {\n  return isArraySchemaType(type) && type.of.every((memberType) => isPrimitiveSchemaType(memberType));\n}\nfunction isBooleanSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"boolean\" : !1;\n}\nfunction isStringSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"string\" : !1;\n}\nfunction isNumberSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"number\" : !1;\n}\nfunction isPrimitiveSchemaType(type) {\n  return isBooleanSchemaType(type) || isStringSchemaType(type) || isNumberSchemaType(type);\n}\nfunction isReferenceSchemaType(type) {\n  return isRecord(type) && (type.name === \"reference\" || isReferenceSchemaType(type.type));\n}\nfunction isImageSchemaType(type) {\n  return isRecord(type) && (type.name === \"image\" || isImageSchemaType(type.type));\n}\nfunction isFileSchemaType(type) {\n  return isRecord(type) && (type.name === \"file\" || isFileSchemaType(type.type));\n}\nfunction isDeprecatedSchemaType(type) {\n  return isRecord(type) ? typeof type.deprecated < \"u\" : !1;\n}\nfunction isDeprecationConfiguration(type) {\n  return isRecord(type) ? typeof type.deprecated < \"u\" : !1;\n}\nfunction isCrossDatasetReferenceSchemaType(type) {\n  return isRecord(type) && (type.name === \"crossDatasetReference\" || isCrossDatasetReferenceSchemaType(type.type));\n}\nfunction isTitledListValue(item) {\n  return typeof item == \"object\" && item !== null && \"title\" in item && \"value\" in item;\n}\nfunction isSpanSchemaType(type) {\n  return isRecord(type) ? Array.isArray(type.annotations) && Array.isArray(type.decorators) : !1;\n}\nfunction isBlockSchemaType(type) {\n  if (!isRecord(type) || !Array.isArray(type.fields)) return !1;\n  const maybeSpanChildren = type.fields.find(isBlockChildrenObjectField), maybeStyle = type.fields.find(isBlockStyleObjectField), maybeList = type.fields.find(isBlockListObjectField);\n  return isBlockChildrenObjectField(maybeSpanChildren) && isBlockStyleObjectField(maybeStyle) && isBlockListObjectField(maybeList);\n}\nfunction isBlockStyleObjectField(field) {\n  return !isRecord(field) || field.name !== \"style\" ? !1 : isRecord(field.type) && field.type.jsonType === \"string\";\n}\nfunction isBlockListObjectField(field) {\n  return !isRecord(field) || field.name !== \"listItem\" ? !1 : isRecord(field.type) && field.type.jsonType === \"string\";\n}\nfunction isBlockChildrenObjectField(field) {\n  return !isRecord(field) || field.name !== \"children\" || !isArraySchemaType(field.type) ? !1 : field.type.of.some(isSpanSchemaType);\n}\nfunction defineType(schemaDefinition, defineOptions) {\n  return schemaDefinition;\n}\nfunction defineField(schemaField, defineOptions) {\n  return schemaField;\n}\nfunction defineArrayMember(arrayOfSchema, defineOptions) {\n  return arrayOfSchema;\n}\nfunction typed(input) {\n  return input;\n}\nconst searchStrategies = [\"groqLegacy\", \"textSearch\", \"groq2024\"];\nfunction isSearchStrategy(maybeSearchStrategy) {\n  return searchStrategies.includes(maybeSearchStrategy);\n}\nfunction isSlug(thing) {\n  return isObject(thing) && typeof thing.current == \"string\";\n}\nfunction isCreateSquashedMutation(mutation) {\n  return \"createSquashed\" in mutation;\n}\nfunction isValidationError(node) {\n  return node.level === \"error\";\n}\nfunction isValidationWarning(node) {\n  return node.level === \"warning\";\n}\nfunction isValidationInfo(node) {\n  return node.level === \"info\";\n}\nexport {\n  defineArrayMember,\n  defineField,\n  defineType,\n  isArrayOfBlocksSchemaType,\n  isArrayOfObjectsSchemaType,\n  isArrayOfPrimitivesSchemaType,\n  isArraySchemaType,\n  isBlockChildrenObjectField,\n  isBlockListObjectField,\n  isBlockSchemaType,\n  isBlockStyleObjectField,\n  isBooleanSchemaType,\n  isCreateIfNotExistsMutation,\n  isCreateMutation,\n  isCreateOrReplaceMutation,\n  isCreateSquashedMutation,\n  isCrossDatasetReference,\n  isCrossDatasetReferenceSchemaType,\n  isDeleteMutation,\n  isDeprecatedSchemaType,\n  isDeprecationConfiguration,\n  isDocumentSchemaType,\n  isFileSchemaType,\n  isImage,\n  isImageSchemaType,\n  isIndexSegment,\n  isIndexTuple,\n  isKeySegment,\n  isKeyedObject,\n  isNumberSchemaType,\n  isObjectSchemaType,\n  isPatchMutation,\n  isPortableTextListBlock,\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  isPrimitiveSchemaType,\n  isReference,\n  isReferenceSchemaType,\n  isSanityDocument,\n  isSearchStrategy,\n  isSlug,\n  isSpanSchemaType,\n  isStringSchemaType,\n  isTitledListValue,\n  isTypedObject,\n  isValidationError,\n  isValidationErrorMarker,\n  isValidationInfo,\n  isValidationInfoMarker,\n  isValidationWarning,\n  isValidationWarningMarker,\n  searchStrategies,\n  typed\n};\n//# sourceMappingURL=index.mjs.map\n","import { isIndexSegment, isKeySegment, isIndexTuple } from \"@sanity/types\";\nconst rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g, reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/, EMPTY_PATH = [], FOCUS_TERMINATOR = \"$\", GROQ_DATA_TYPE_VALUES = [\"true\", \"false\", \"null\"];\nfunction get(obj, path, defaultVal) {\n  const select = typeof path == \"string\" ? fromString(path) : path;\n  if (!Array.isArray(select))\n    throw new Error(\"Path must be an array or a string\");\n  let acc = obj;\n  for (let i = 0; i < select.length; i++) {\n    const segment = select[i];\n    if (isIndexSegment(segment)) {\n      if (!Array.isArray(acc))\n        return defaultVal;\n      acc = acc[segment];\n    }\n    if (isKeySegment(segment)) {\n      if (!Array.isArray(acc))\n        return defaultVal;\n      acc = acc.find((item) => item._key === segment._key);\n    }\n    if (typeof segment == \"string\" && (acc = typeof acc == \"object\" && acc !== null ? acc[segment] : void 0), typeof acc > \"u\")\n      return defaultVal;\n  }\n  return acc;\n}\nconst pathsMemo = /* @__PURE__ */ new Map();\nfunction pathFor(path) {\n  if (path.length === 0)\n    return EMPTY_PATH;\n  const asString = toString(path);\n  return pathsMemo.has(asString) ? pathsMemo.get(asString) : (pathsMemo.set(asString, path), Object.freeze(path), path);\n}\nfunction isEqual(path, otherPath) {\n  return path.length === otherPath.length && path.every((segment, i) => isSegmentEqual(segment, otherPath[i]));\n}\nfunction numEqualSegments(path, otherPath) {\n  const length = Math.min(path.length, otherPath.length);\n  for (let i = 0; i < length; i++)\n    if (!isSegmentEqual(path[i], otherPath[i]))\n      return i;\n  return length;\n}\nfunction isSegmentEqual(segmentA, segmentB) {\n  return isKeySegment(segmentA) && isKeySegment(segmentB) ? segmentA._key === segmentB._key : isIndexSegment(segmentA) ? Number(segmentA) === Number(segmentB) : isIndexTuple(segmentA) && isIndexTuple(segmentB) ? segmentA[0] === segmentB[0] && segmentA[1] === segmentB[1] : segmentA === segmentB;\n}\nfunction hasFocus(focusPath, path) {\n  const withoutTerminator = focusPath[focusPath.length - 1] === FOCUS_TERMINATOR ? focusPath.slice(0, -1) : focusPath;\n  return isEqual(withoutTerminator, path);\n}\nfunction hasItemFocus(focusPath, item) {\n  return focusPath.length === 1 && isSegmentEqual(focusPath[0], item);\n}\nfunction isExpanded(segment, focusPath) {\n  const [head, ...tail] = focusPath;\n  return tail.length > 0 && isSegmentEqual(segment, head);\n}\nfunction startsWith(prefix, path) {\n  return prefix.every((segment, i) => isSegmentEqual(segment, path[i]));\n}\nfunction trimLeft(prefix, path) {\n  if (prefix.length === 0 || path.length === 0)\n    return path;\n  const [prefixHead, ...prefixTail] = prefix, [pathHead, ...pathTail] = path;\n  return isSegmentEqual(prefixHead, pathHead) ? pathFor(trimLeft(prefixTail, pathTail)) : path;\n}\nfunction trimRight(suffix, path) {\n  const sufLen = suffix.length, pathLen = path.length;\n  if (sufLen === 0 || pathLen === 0)\n    return path;\n  let i = 0;\n  for (; i < sufLen && i < pathLen && isSegmentEqual(path[pathLen - i - 1], suffix[sufLen - i - 1]); )\n    i++;\n  return pathFor(path.slice(0, pathLen - i));\n}\nfunction trimChildPath(path, childPath) {\n  return startsWith(path, childPath) ? trimLeft(path, childPath) : EMPTY_PATH;\n}\nfunction toString(path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return path.reduce((target, segment, i) => {\n    const isHead = i === 0;\n    if (typeof segment == \"number\")\n      return `${target}[${segment}]`;\n    if (typeof segment == \"string\")\n      return isHead ? segment : GROQ_DATA_TYPE_VALUES.includes(segment) ? `${target}[\"${segment}\"]` : `${target}.${segment}`;\n    if (isKeySegment(segment) && segment._key)\n      return `${target}[_key==\"${segment._key}\"]`;\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return `${target}[${from}:${to}]`;\n    }\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``);\n  }, \"\");\n}\nfunction _resolveKeyedPath(value, path) {\n  if (path.length === 0)\n    return path;\n  const [next, ...rest] = path;\n  if (typeof next == \"number\") {\n    if (!Array.isArray(value) || !(next in value))\n      return [];\n    const item = value[next];\n    return [typeof item?._key == \"string\" ? { _key: item._key } : next, ..._resolveKeyedPath(item, rest)];\n  }\n  const nextVal = get(value, [next]);\n  return [next, ..._resolveKeyedPath(nextVal, rest)];\n}\nfunction resolveKeyedPath(value, path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return pathFor(_resolveKeyedPath(value, path));\n}\nfunction fromString(path) {\n  if (typeof path != \"string\")\n    throw new Error(\"Path is not a string\");\n  const segments = path.match(rePropName);\n  if (!segments)\n    throw new Error(\"Invalid path string\");\n  return segments.map(normalizePathSegment);\n}\nfunction normalizePathSegment(segment) {\n  return isIndexSegment(segment) ? normalizeIndexSegment(segment) : isKeySegment(segment) ? normalizeKeySegment(segment) : isIndexTuple(segment) ? normalizeIndexTupleSegment(segment) : segment;\n}\nfunction normalizeIndexSegment(segment) {\n  return Number(segment.replace(/[^\\d]/g, \"\"));\n}\nfunction normalizeKeySegment(segment) {\n  return { _key: segment.match(reKeySegment)[1] };\n}\nfunction normalizeIndexTupleSegment(segment) {\n  const [from, to] = segment.split(\":\").map((seg) => seg === \"\" ? seg : Number(seg));\n  return [from, to];\n}\nexport {\n  FOCUS_TERMINATOR,\n  _resolveKeyedPath,\n  fromString,\n  get,\n  hasFocus,\n  hasItemFocus,\n  isEqual,\n  isExpanded,\n  isSegmentEqual,\n  numEqualSegments,\n  pathFor,\n  resolveKeyedPath,\n  startsWith,\n  toString,\n  trimChildPath,\n  trimLeft,\n  trimRight\n};\n//# sourceMappingURL=paths.mjs.map\n","import {useCallback, useMemo, useSyncExternalStore} from 'react'\nimport {\n  actor,\n  emptyActor,\n  isEmptyActor,\n  listeners,\n  type EmptyActor,\n  type MutatorActor,\n} from '../optimistic/context'\n\nexport function useOptimisticActor(): MutatorActor | EmptyActor {\n  const subscribe = useCallback((listener: () => void) => {\n    listeners.add(listener)\n    return () => listeners.delete(listener)\n  }, [])\n\n  const actorRef = useSyncExternalStore(\n    subscribe,\n    () => actor,\n    () => emptyActor,\n  )\n\n  return actorRef\n}\n\nexport function useOptimisticActorReady(): boolean {\n  const actor = useOptimisticActor()\n  return useMemo(() => !isEmptyActor(actor), [actor])\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {SanityDocument} from '@sanity/client'\nimport {getDraftId, getPublishedId} from '@sanity/client/csm'\nimport {createIfNotExists, patch} from '@sanity/mutate'\nimport {isMaybePreviewIframe, isMaybePreviewWindow} from '@sanity/presentation-comlink'\nimport {get as getAtPath} from '@sanity/util/paths'\nimport {useCallback} from 'react'\nimport {isEmptyActor, type MutatorActor} from '../optimistic/context'\nimport type {\n  DocumentsGet,\n  DocumentsMutate,\n  OptimisticDocumentPatches,\n  Path,\n  PathValue,\n} from '../optimistic/types'\nimport {useOptimisticActor} from './useOptimisticActor'\n\nfunction debounce<F extends (...args: Parameters<F>) => ReturnType<F>>(fn: F, timeout: number): F {\n  let timer: ReturnType<typeof setTimeout>\n  return ((...args: Parameters<F>) => {\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      fn.apply(fn, args)\n    }, timeout)\n  }) as F\n}\n\nfunction getDocumentsAndSnapshot<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  const inFrame = isMaybePreviewIframe()\n  const inPopUp = isMaybePreviewWindow()\n\n  if (isEmptyActor(actor) || (!inFrame && !inPopUp)) {\n    throw new Error('The `useDocuments` hook cannot be used in this context')\n  }\n\n  const draftId = getDraftId(id)\n  const publishedId = getPublishedId(id)\n  const documents = actor.getSnapshot().context?.documents\n\n  const draftDoc = documents?.[draftId]\n  const publishedDoc = documents?.[publishedId]\n  const doc = draftDoc || publishedDoc\n\n  if (!doc) {\n    throw new Error(`Document \"${id}\" not found`)\n  }\n\n  // Helper to get the snapshot from the draft document if it exists, otherwise\n  // fall back to the published document\n  const getDocumentSnapshot = () =>\n    (draftDoc.getSnapshot().context?.local || publishedDoc.getSnapshot().context?.local) as\n      | SanityDocument<T>\n      | null\n      | undefined\n\n  const snapshot = getDocumentSnapshot()\n  const snapshotPromise = new Promise<SanityDocument<T> | null>((resolve) => {\n    if (snapshot) {\n      resolve(snapshot)\n    } else {\n      const subscriber = doc.on('ready', (event) => {\n        // Assert type here as the original document mutator machine doesn't\n        // emit a 'ready' event. We provide a custom action to emit it in this\n        // package's internal `createDatasetMutator` function. <3 xstate.\n        const {snapshot} = event as unknown as {snapshot: SanityDocument<T> | null | undefined}\n        resolve(snapshot || null)\n        subscriber.unsubscribe()\n      })\n    }\n  })\n\n  const getSnapshot = () => snapshotPromise\n\n  return {\n    draftDoc,\n    draftId,\n    getSnapshot,\n    publishedDoc,\n    publishedId,\n    /**\n     * @deprecated - use `getSnapshot` instead\n     */\n    get snapshot() {\n      // Maintain original error throwing behaviour, to avoid breaking changes\n      if (!snapshot) {\n        throw new Error(`Snapshot for document \"${id}\" not found`)\n      }\n      return snapshot\n    },\n  }\n}\n\nfunction createDocumentCommit<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  return (): void => {\n    const {draftDoc} = getDocumentsAndSnapshot<T>(id, actor)\n    draftDoc.send({type: 'submit'})\n  }\n}\n\n/**\n * @deprecated - superseded by `createDocumentGetSnapshot`\n */\nfunction createDocumentGet<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  return <P extends Path<T, keyof T>>(\n    path?: P,\n  ): PathValue<T, P> | SanityDocument<T> | undefined => {\n    const {snapshot} = getDocumentsAndSnapshot<T>(id, actor)\n\n    return path\n      ? (getAtPath(snapshot, path) as PathValue<T, P>)\n      : (snapshot as unknown as SanityDocument<T>)\n  }\n}\n\nfunction createDocumentGetSnapshot<T extends Record<string, any>>(\n  id: string,\n  actor: MutatorActor,\n): () => Promise<SanityDocument<T> | null> {\n  const {getSnapshot} = getDocumentsAndSnapshot<T>(id, actor)\n  return getSnapshot\n}\n\nfunction createDocumentPatch<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  return async (\n    patches: OptimisticDocumentPatches<T>,\n    options?: {commit?: boolean | {debounce: number}},\n  ): Promise<void> => {\n    // Destructure the function result in two steps as we need access to the\n    // `result.snapshot` property in the getter, but don't want to execute the\n    // getter prematurely as it may throw\n    const result = getDocumentsAndSnapshot<T>(id, actor)\n    const {draftDoc, draftId, getSnapshot, publishedId} = result\n\n    const {commit = true} = options || {}\n\n    const context = {\n      draftId,\n      publishedId,\n      /**\n       * @deprecated - use `getSnapshot` instead\n       */\n      get snapshot() {\n        return result.snapshot\n      },\n      getSnapshot,\n    }\n\n    const resolvedPatches = await (typeof patches === 'function' ? patches(context) : patches)\n\n    const _snapshot = await getSnapshot()\n\n    if (!_snapshot) {\n      throw new Error(`Snapshot for document \"${id}\" not found`)\n    }\n\n    draftDoc.send({\n      type: 'mutate',\n      mutations: [\n        // Attempt to create the draft document, it might not exist if the\n        // snapshot was from the published document\n        createIfNotExists({..._snapshot, _id: draftId}),\n        // Patch the draft document with the resolved patches\n        patch(draftId, resolvedPatches),\n      ],\n    })\n\n    if (commit) {\n      if (typeof commit === 'object' && 'debounce' in commit) {\n        const debouncedCommit = debounce(() => draftDoc.send({type: 'submit'}), commit.debounce)\n        debouncedCommit()\n      } else {\n        draftDoc.send({type: 'submit'})\n      }\n    }\n  }\n}\n\nexport function useDocuments(): {\n  getDocument: DocumentsGet\n  mutateDocument: DocumentsMutate\n} {\n  const actor = useOptimisticActor() as MutatorActor\n\n  const getDocument: DocumentsGet = useCallback(\n    <T extends Record<string, any>>(documentId: string) => {\n      return {\n        id: documentId,\n        commit: createDocumentCommit(documentId, actor),\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore - Type instantiation is excessively deep and possibly infinite.\n        get: createDocumentGet(documentId, actor),\n        getSnapshot: createDocumentGetSnapshot<T>(documentId, actor),\n        patch: createDocumentPatch<T>(documentId, actor),\n      }\n    },\n    [actor],\n  )\n\n  const mutateDocument: DocumentsMutate = useCallback(\n    (id, mutations, options) => {\n      const {draftDoc} = getDocumentsAndSnapshot(id, actor)\n      const {commit = true} = options || {}\n\n      draftDoc.send({\n        type: 'mutate',\n        mutations: mutations,\n      })\n\n      if (commit) {\n        if (typeof commit === 'object' && 'debounce' in commit) {\n          const debouncedCommit = debounce(() => draftDoc.send({type: 'submit'}), commit.debounce)\n          debouncedCommit()\n        } else {\n          draftDoc.send({type: 'submit'})\n        }\n      }\n    },\n    [actor],\n  )\n\n  return {getDocument, mutateDocument}\n}\n","import getRandomValues from 'get-random-values-esm'\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  getRandomValues(rnds8)\n  return rnds8\n}\n\nconst getByteHexTable = (() => {\n  let table: string[]\n  return () => {\n    if (table) {\n      return table\n    }\n    table = []\n    for (let i = 0; i < 256; ++i) {\n      table[i] = (i + 0x100).toString(16).slice(1)\n    }\n    return table\n  }\n})()\n\nexport function randomKey(length?: number): string {\n  const table = getByteHexTable()\n  return whatwgRNG(length)\n    .reduce((str, n) => str + table[n], '')\n    .slice(0, length)\n}\n","import type {SanityDocument} from '@sanity/client'\nimport {at, insert, truncate, type NodePatchList} from '@sanity/mutate'\nimport type {SanityNode} from '@sanity/presentation-comlink'\nimport {get} from '@sanity/util/paths'\nimport type {OptimisticDocument} from '../optimistic/types'\nimport {randomKey} from './randomKey'\n\nexport function getArrayItemKeyAndParentPath(pathOrNode: string | SanityNode): {\n  path: string\n  key: string\n  hasExplicitKey: boolean\n} {\n  const elementPath = typeof pathOrNode === 'string' ? pathOrNode : pathOrNode.path\n\n  const lastDotIndex = elementPath.lastIndexOf('.')\n  const lastPathItem = elementPath.substring(lastDotIndex + 1, elementPath.length)\n\n  if (!lastPathItem.indexOf('[')) throw new Error('Invalid path: not an array')\n\n  const lastArrayIndex = elementPath.lastIndexOf('[')\n  const path = elementPath.substring(0, lastArrayIndex)\n\n  let key\n  let hasExplicitKey\n\n  if (lastPathItem.includes('_key')) {\n    // explicit [_key=\"...\"]\n\n    const startIndex = lastPathItem.indexOf('\"') + 1\n    const endIndex = lastPathItem.indexOf('\"', startIndex)\n\n    key = lastPathItem.substring(startIndex, endIndex)\n\n    hasExplicitKey = true\n  } else {\n    // indexes [int]\n    const startIndex = lastPathItem.indexOf('[') + 1\n    const endIndex = lastPathItem.indexOf(']', startIndex)\n\n    key = lastPathItem.substring(startIndex, endIndex)\n\n    hasExplicitKey = false\n  }\n\n  if (!path || !key) throw new Error('Invalid path')\n\n  return {\n    path,\n    key,\n    hasExplicitKey,\n  }\n}\n\nexport function getArrayDuplicatePatches(\n  node: SanityNode,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  snapshot: SanityDocument<Record<string, any>>,\n  position: 'before' | 'after' = 'after',\n): NodePatchList {\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n\n  const item = get(snapshot, node.path) as object\n  const duplicate = {...item, _key: randomKey()}\n\n  return [at(arrayPath, insert(duplicate, position, {_key: itemKey}))]\n}\n\nexport function getArrayRemovePatches(\n  node: SanityNode,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  snapshot: SanityDocument<Record<string, any>>,\n): NodePatchList {\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n  const array = get(snapshot, arrayPath) as {_key: string}[]\n  const currentIndex = array.findIndex((item) => item._key === itemKey)\n  return [at(arrayPath, truncate(currentIndex, currentIndex + 1))]\n}\n\nexport function getArrayInsertPatches(\n  node: SanityNode,\n  insertType: string,\n  position: 'before' | 'after',\n): NodePatchList {\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n  const insertKey = randomKey()\n  const referenceItem = {_key: itemKey}\n  return [at(arrayPath, insert([{_type: insertType, _key: insertKey}], position, referenceItem))]\n}\n\nexport async function getArrayMovePatches(\n  node: SanityNode,\n  doc: OptimisticDocument,\n  moveTo: 'previous' | 'next' | 'first' | 'last',\n): Promise<NodePatchList> {\n  if (!node.type) throw new Error('Node type is missing')\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n\n  const snapshot = await doc.getSnapshot()\n  const array = get(snapshot, arrayPath) as {_key: string}[]\n  const item = get(snapshot, node.path)\n  const currentIndex = array.findIndex((item) => item._key === itemKey)\n\n  let nextIndex = -1\n  let position: 'before' | 'after' = 'before'\n\n  if (moveTo === 'first') {\n    if (currentIndex === 0) return []\n    nextIndex = 0\n    position = 'before'\n  } else if (moveTo === 'last') {\n    if (currentIndex === array.length - 1) return []\n    nextIndex = -1\n    position = 'after'\n  } else if (moveTo === 'next') {\n    if (currentIndex === array.length - 1) return []\n    nextIndex = currentIndex\n    position = 'after'\n  } else if (moveTo === 'previous') {\n    if (currentIndex === 0) return []\n    nextIndex = currentIndex - 1\n    position = 'before'\n  }\n\n  return [\n    at(arrayPath, truncate(currentIndex, currentIndex + 1)),\n    at(arrayPath, insert(item, position, nextIndex)),\n  ]\n}\n"],"names":["getDraftId","getPublishedId","createIfNotExists","patch","at","insert","truncate","isMaybePreviewIframe","isMaybePreviewWindow","useCallback","useSyncExternalStore","useMemo","listeners","actor","emptyActor","isEmptyActor","getRandomValues","reKeySegment","reIndexTuple","isIndexSegment","segment","test","isKeySegment","trim","rePropName","get","obj","path","defaultVal","select","Error","segments","match","map","normalizePathSegment","fromString","Array","isArray","acc","i","length","find","item","_key","Number","replace","normalizeIndexSegment","normalizeKeySegment","from","to","isIndexTuple","split","seg","normalizeIndexTupleSegment","useOptimisticActor","subscribe","listener","add","delete","useOptimisticActorReady","debounce","fn","timeout","timer","args","clearTimeout","setTimeout","apply","getDocumentsAndSnapshot","id","inFrame","inPopUp","draftId","publishedId","documents","getSnapshot","context","draftDoc","publishedDoc","doc","snapshot","local","snapshotPromise","Promise","resolve","subscriber","on","event","unsubscribe","createDocumentCommit","send","type","createDocumentGet","getAtPath","createDocumentGetSnapshot","createDocumentPatch","async","patches","options","result","commit","resolvedPatches","_snapshot","mutations","_id","useDocuments","getDocument","documentId","mutateDocument","getByteHexTable","table","toString","slice","randomKey","rnds8","Uint8Array","whatwgRNG","reduce","str","n","getArrayItemKeyAndParentPath","pathOrNode","elementPath","lastDotIndex","lastIndexOf","lastPathItem","substring","indexOf","lastArrayIndex","key","hasExplicitKey","includes","startIndex","endIndex","getArrayDuplicatePatches","node","position","arrayPath","itemKey","duplicate","getArrayRemovePatches","currentIndex","findIndex","getArrayInsertPatches","insertType","insertKey","_type","getArrayMovePatches","moveTo","array","nextIndex"],"mappings":"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","x_google_ignoreList":[0,1]}